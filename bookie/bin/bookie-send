#!/usr/bin/env ruby

require 'optparse'

#For development:
#$LOAD_PATH << 'lib'

#To consider: restore for production?
=begin
unless Process.uid == 0
  $stderr.puts "This command must be run as root."
  exit 1
end
=end

require 'bookie/sender'

config_file = '/etc/bookie/config.json'
will_decommission = false
system_hostname = nil
system_end_time = nil

opts = OptionParser.new do |opts|
  opts.banner = "Usage: bookie-send [data-file] [options]"
  
  opts.on('-c', '--config FILE', String, "use the given configuration file") do |file|
    config_file = file
  end
  
  opts.on("--decommission [HOSTNAME [TIME]]",
  String, String,
  "Decommission the system with the given hostname, recording the given time as its end time") do |hostname, time|
    will_decommission = true
    system_hostname = hostname if hostname
    system_end_time = Time.parse(time) if time
  end
end
begin
  opts.parse!(ARGV)
rescue OptionParser::ParseError => e
  puts e.message
  puts opts
  exit 1
end

config = Bookie::Config.new(config_file)
config.connect

system_hostname ||= config.hostname
system_end_time ||= Time.now

filename = ARGV[0]
fail("No operation specified") unless filename || will_decommission

if filename
  sender = Bookie::Sender.new(config)
  sender.send_data(filename)
end

if will_decommission
  Bookie::Database::Lock[:systems].synchronize do
    system = Bookie::Database::System.active_systems.find_by_name(system_hostname)
    if system
      puts "Note: make sure that all of this system's jobs have been recorded in the database before decommissioning it."
      STDOUT.write "Decommission this system? "
      response = nil
      until response
        response = STDIN.gets.chomp.downcase
        case response
        when "yes"
          system.decommission(system_end_time)
        when "no"
          exit 0
        else
          STDOUT.write("Please answer 'yes' or 'no'.")
          response = nil
        end
      end
    else
      stderr.puts "No active system with hostname #{system_hostname}"
    end
  end
end
