#!/usr/bin/env ruby

require 'optparse'

require 'bookie/formatter'

DEFAULT_DETAILS_PER_PAGE = 20

config_filename = ENV['BOOKIE_CONFIG'] || '/etc/bookie/config.json'

#Data options
time_min, time_max = nil
#TODO: make into a Hash?
command_filter = nil
user_filter = nil
system_filter = nil
system_type_filter = nil

#Printing options
include_details = false
details_per_page = DEFAULT_DETAILS_PER_PAGE
details_page = 1

output_type = :stdout
filename = nil

#Process arguments:

opts = OptionParser.new do |opts|
  opts.banner = "Usage: bookie-data [options]"

  opts.on('-c', '--config FILE', String, "use the given configuration file") do |file|
    config_filename = file
  end

  opts.on('-d', '--details', "include full details") do
    include_details = true
  end

  opts.on('-p', '--page PAGE', Integer, "show only the given page of details") do |page_num|
    if page_num < 1
      STDERR.puts "invalid page number: #{page_num}"
      exit 1
    end
    include_details = true
    details_page = page_num
  end

  opts.on('-l', '--limit COUNT', Integer, "limit the number of jobs per page") do |count|
    if count < 1
      STDERR.PUTS "invalid page length: #{count}"
      exit 1
    end
    include_details = true
    details_per_page = count
  end

  opts.on('-u', '--user NAME', "filter by username") do |name|
    user_filter = name
  end

  opts.on('-m', '--command', "filter by command") do |cmd|
    command_filter = cmd
  end

  opts.on('-s', '--system HOSTNAME', "filter by system") do |hostname|
    system_filter = hostname
  end

  opts.on('-t', '--type TYPE', "filter by system type") do |type|
    system_type_filter = type
  end

  opts.on('-r', '--time BEGIN,END', Array, "filter by a time range") do |t|
    time_min = Time.parse(t[0])
    time_max = Time.parse(t[1])
  end

  opts.on('-o', '--output-file FILENAME', "send formatted output to FILENAME",
    "Output format is inferred from the filename extension.") do |output_filename|
    filename = output_filename
    case filename
    when /\.xls$/
      output_type = :spreadsheet
    when /\.csv$/
      output_type = :comma_dump
    else
      STDERR.puts "unrecognized output file extension"
      exit 1
    end
  end

  opts.on_tail('-h', '--help', "Show this message") do
    puts opts
    exit
  end
end

begin
  opts.parse!(ARGV)
rescue OptionParser::ParseError => e
  STDERR.puts e.message
  STDERR.puts opts
  exit 1
end

config = Bookie::Config.new(config_filename)
config.connect

jobs = Bookie::Database::Job
job_summaries = Bookie::Database::JobSummary
system_capacities = Bookie::Database::SystemCapacity

if command_filter then
    jobs = jobs.where(command_name: command_filter)
    job_summaries = job_summaries.where(command_name: command_filter)
end

if user_filter then
  user = User.find(name: user_filter)
  jobs = jobs.where(user: user)
  job_summaries = job_summaries.where(user: user)
end

if system_filter then
  system = Bookie::Database::System.find!(name: system_filter)
  jobs = jobs.where(system: system)
  job_summaries = job_summaries.where(system: system)
  system_capacities = system_capacities.where(system: system)
end

if system_type_filter then
  type = Bookie::Database::SystemType.find(name: system_type_filter)
  unless type
    STDERR.puts "unknown system type '#{system_type_filter}'"
    exit 1
  end
  #TODO: test.
  systems = Bookie::Database::System.where(system_type: type)
  jobs = jobs.joins(:system).merge(systems)
  job_summaries = job_summaries.joins(:system).merge(systems)
  system_capacities = system_capacities.joins(:system).merge(systems)
end

jobs_summary = job_summaries.summary(jobs, time_min, time_max)
systems_summary = system_capacities.summary(time_min, time_max)

formatter = Bookie::Formatter.new(output_type, filename)
formatter.print_summary(jobs_summary, systems_summary)

if include_details
  #TODO: include separator or blank line.

  jobs = jobs.by_time_range(time_range) if time_range
  jobs = jobs.order(:start_time)

  if details_per_page
    page_start = details_per_page * (details_page - 1)
    if jobs.count <= page_start
      puts "No jobs on page #{details_page}"
    else
      jobs = jobs.offset(page_start).limit(details_per_page)
    end
  end
  formatter.print_jobs(jobs.all_with_associations)
end

formatter.flush

