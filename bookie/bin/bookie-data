#!/usr/bin/env ruby

require 'optparse'

#For development
$LOAD_PATH << 'lib'

require 'bookie/formatter'

jobs = Bookie::Database::Job
systems = Bookie::Database::System

config_filename = '/etc/bookie/config.json'
include_details = false

output_type = :stdout
#Filename (needs to be stored for Spreadsheet)
filename = nil
output_file = STDOUT
#The method to be called on output_file to save it
#Usually nil
save_method = nil

t_min = nil
t_max = nil

#Process arguments

#The first run only gets the configuration filename
ARGV.each_with_index do |value, i|
  if value == '-c' || value == '--config'
    v = ARGV[i + 1]
    #If the argument is missing, ignore it; OptionParser will catch it later.
    config_filename = v if v
  end
end

config = Bookie::Config.new(config_filename)
config.connect

opts = OptionParser.new do |opts|
  opts.banner = "Usage: bookie-data [options]"
  
  opts.on('-c', '--config FILE', String, "use the given configuration file") do |file|
    #This is just here so it shows up in the message.
  end
  
  opts.on('-d', '--details', "include full details") do
    include_details = true
  end
  
  opts.on('-u', '--user NAME', "filter by username") do |name|
    jobs = jobs.by_user_name(name)
  end
  
  opts.on('-g', '--group NAME' "filter by group") do |name|
    jobs = jobs.by_group_name(name)
  end
  
  opts.on('-s', '--system HOSTNAME', "filter by system") do |hostname|
    jobs = jobs.by_system_name(hostname)
    systems = systems.by_name(hostname)
    # jobs = System.find_by_name(hostname).jobs
  end
  
  opts.on('-t', '--type TYPE', "filter by system type") do |type|
    t = Bookie::Database::SystemType.find_by_name(type)
    unless t
      STDERR.puts "Unknown system type '#{type}'"
      exit 1
    end
    jobs = jobs.by_system_type(t)
    systems = systems.by_system_type(t)
  end
  
  opts.on('-r', '--time BEGIN END', "filter by a time range") do |t_begin, t_end|
    t_min = Time.parse(t_begin)
    t_max = Time.parse(t_end)
  end
  
  opts.on('-o', '--output-file FILENAME', "send formatted output to FILENAME") do |output_filename|
    filename = output_filename
    case filename
    when /\.xls$/
      output_type = :spreadsheet
      output_file = Spreadsheet::Workbook.new
      save_method = :write
    when /\.csv$/
      output_type = :comma_dump
      output_file = File.open(filename, "w")
    else
      $stderr.puts "Unrecognized output file extension"
      exit 1
    end
  end
end
begin
  opts.parse!(ARGV)
rescue OptionParser::ParseError => e
  puts e.message
  puts opts
  exit 1
end

formatter = Bookie::Formatter::Formatter.new(config, output_type)

#To do: ensure that the query isn't performed twice?
formatter.print_summary(jobs, systems, output_file, t_min, t_max)
formatter.print_non_response_warnings(output_file)
jobs = jobs.by_time_range_inclusive(t_min, t_max) if t_min
formatter.print_jobs(jobs, systems, output_file) if include_details

if output_file
  output_file.send(save_method, filename) if save_method
end
